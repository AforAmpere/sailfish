Problem setups
==============

.. py:currentmodule:: sailfish.setup

Simulations are configured by an object called a `setup`. The setup specifies
initial conditions, a mesh, boundary conditions, and a solver class, among
several other optional things. Setups can be specific test problems used for
code validation, or they can encompass whole classes of research problems,
with many internal parameters. The degrees of freedom within a setup are
called `model parameters`, and these have default values which define a
fiducial model, but they can also be overridden from command line input
or other sources of configuration.

Minimal example
^^^^^^^^^^^^^^^

Here is a minimal setup, which defines a 1D relativistic hydrodynamics problem
consisting of a periodic density wave:

.. code-block:: python

    from math import sin, pi
    from sailfish.setup import Setup
    from sailfish.mesh import PlanarCartesianMesh

    class DensityWave(Setup):
        """
        A sinusoidal variation of density propagating to the right.
        """
        def primitive(self, t, x, p):
            p[0] = 1.0 + 0.1 * sin(2.0 * pi * x) # gas density
            p[1] = 0.5 # velocity
            p[2] = 1.0 # gas pressure

        def mesh(self, num_zones):
            return PlanarCartesianMesh(0.0, 1.0, num_zones)

        @property
        def solver(self):
            return "srhd_1d"

        @property
        def boundary_condition(self):
            return "periodic"

This setup uses the `srhd_1d` solver (relativistic 1D hydrodynamics) with
cartesian coordinates, on a domain from 0.0 to 1.0. The boundary condition
is periodic, and the hydrodynamic primitive data is initialized to a sin
wave.

Required methods
^^^^^^^^^^^^^^^^

Our setup class inherits (is a sub-class of) the :py:obj:`Setup` base class.
The base class provides a lot of functionality in the form of methods that
have trivial default implementations, but can be overridden if needed. The
four methods implemented in the example above are required for the setup to be
instantiated (they are `abstract` methods in the base class).

The :py:obj:`Setup.primitive` method takes as arguments the time, a coordinate
position, and a slice of a primitive variable array where the initial
condition should be written. The number and meaning of primitive variables
depends on the system being solved, and the system is a property of the solver
class, which is identified by the :py:obj:`Setup.solver` property. The object
returned by the :py:obj:`Setup.mesh` method describes the physical extent of
the simulation domain, as well as how it is discretized and what kind of
coordinates are used (i.e. cartesian or spherical). The
:py:obj:`Setup.boundary_condition` method returns string to identify the type
of boundary condition to be applied. The mesh and boundary condition
objects must be compatible with (supported by) the solver, otherwise the
solver will through an exception when it's constructed.

Notice the mesh method takes a parameter specifying the number of zones, which
is provided from driver, which instantiates the setup. This parameter can be
interpreted freely by the setup in creating a mesh, for example if your setup
uses a :py:obj:`sailfish.mesh.LogSphericalMesh`, it makes sense to interpret
this parameter as the number of zones per decade in radius.

Choosing a setup
^^^^^^^^^^^^^^^^

Setup sub-classes are automatically discovered when sailfish is imported or
run from the command line. The first argument to the command line tool is the
name of a setup class, converted to dash-case, i.e. you could run the setup
above in a default configuration by running :code:`sailfish density-wave`. The
command line tool will print the setup documentation to the terminal if
invoked as :code:`sailfish density-wave --describe`. It's good practice to
give your setup class an accurate doc string. 


Model parameters
^^^^^^^^^^^^^^^^

A setup can have internal degrees of freedom to be configured at runtime,
which are referred to as `model parameters`. To add a model parameter to a
setup, just define it as a class variable using the :py:obj:`param`
constructor:

.. code-block:: python

    from sailfish.setup import Setup, param

    class DensityWave(Setup):
        wavenumber = param(1, "integer wavenumber of the sinusoid")
        velocity = param(0.0, "speed of the wave")

        # ...

The two positional arguments to :py:obj:`param` are a default value (from
which the parameter type is inferred), and a help message. An optional keyword
argument :code:`mutable=True` can be supplied to indicate that a parameter can
be changed in a restarted run from its initial value. For the model parameters
that only influence the initial condition, it doesn't make sense to make them
mutable.

Model parameters are passed to the setup class from the command line as
key-value pairs like this:
:code:`sailfish density-wave --model amplitude=0.5 wavenumber=2`.
