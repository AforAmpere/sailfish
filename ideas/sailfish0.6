#!/usr/bin/env python3


from argparse import ArgumentParser, SUPPRESS
from collections import deque
from collections.abc import Mapping
from dataclasses import asdict, dataclass
from itertools import chain, product
from json import load as load_json, dumps as dumps_json
from logging import getLogger

from app_config import Sailfish, Driver, Report, Strategy, Scheme
from new_kernels import perf_time_sequence, configure_kernel_module
from solver import make_solver


# from rich import box
# from rich.console import Console, Group
# from rich.live import Live
# from rich.logging import RichHandler
# from rich.panel import Panel
# from rich.pretty import Pretty
# from rich.progress import Progress
# from rich.syntax import Syntax
# from rich.table import Table
# from rich.traceback import install as install_rich_traceback

# class Plotting:
#     def __init__(self, app):
#         self._axes = None
#         self._line = None
#         self._live = app.plot == "live"

#         if app.plot:
#             from matplotlib import pyplot as plt

#             if app.plot == "live":
#                 plt.ion()
#             self.plt = plt

#     def update(self, state):
#         if not self._live:
#             return
#         elif self._axes is None:
#             self.plot(state)
#         elif self.plt.get_fignums():
#             self.plot(state)
#             self._fig.canvas.flush_events()

#     def plot(self, state, action=None):
#         from numpy import linspace

#         p = state.primitive
#         x = linspace(0.0, 1.0, p.shape[0])
#         line = self._line

#         if line is None:
#             self._line = self.axes().plot(x, p[:, 0], mfc="none")[0]
#         else:
#             line.set_ydata(p[:, 0])

#         if action == "show":
#             self.plt.show()

#     def axes(self):
#         if self._axes:
#             return self._axes
#         else:
#             from matplotlib import pyplot as plt

#             fig = plt.figure()
#             ax1 = fig.add_subplot(111)
#             self._axes = ax1
#             self._fig = fig
#             return ax1


# class Dashboard:
#     """
#     A rich-renderable run monitor
#     """

#     def __init__(self, app=None):
#         self._app = app
#         self.group = Group("", "", "")

#     @property
#     def app(self):
#         return self._app

#     @app.setter
#     def app(self, app):
#         progress = Progress()
#         duration = app.driver.tfinal - app.driver.tstart
#         run_task = progress.add_task("running...", total=duration)

#         self._app = app
#         self.progress = progress
#         self.run_task = run_task
#         self.reports = deque()
#         self.perf_timer = perf_time_sequence(mode=app.hardware)
#         self.group.renderables[0] = self.app_config()
#         self.group.renderables[1] = self.reports_table()
#         self.group.renderables[2] = self.progress

#     def reports_table(self):
#         table = Table(expand=True)
#         table.add_column("iteration", style="cyan", justify="right")
#         table.add_column("time", style="green")
#         table.add_column("zones per second (millions)", style="magenta", justify="left")
#         reports = self.reports

#         for report in reports:
#             table.add_row(
#                 f"{report.iteration}",
#                 f"{report.time:0.5f}",
#                 f"{report.zones_per_second/1e6:0.3f}",
#             )

#         table.add_section()
#         avg_zps = sum(r.zones_per_second for r in reports) / max(1, len(reports))
#         table.add_row(None, None, f"{avg_zps/1e6:0.3f}", style="italic")
#         return table

#     def app_config(self):
#         if self.app.show_config is None:
#             return str()
#         if self.app.show_config == "table":
#             return self.app
#         if self.app.show_config == "pretty":
#             return Pretty(self.app)
#         if self.app.show_config == "json":
#             return Syntax(dumps_json(asdict(self.app), indent=4), lexer="json")
#         if self.app.show_config == "dict":
#             return Pretty(asdict(self.app))

#     def update(self, state):
#         fold = self.app.driver.report.cadence
#         evolved_time = state.time - self.app.driver.tstart
#         zps = state.total_zones / next(self.perf_timer) * fold
#         report = iteration_report(state.iteration, state.time, zps)

#         self.progress.update(self.run_task, completed=evolved_time)
#         self.reports.append(report)

#         if len(self.reports) > 20:
#             self.reports.popleft()

#         self.group.renderables[1] = self.reports_table()

#     def render(self):
#         return Panel.fit(self.group, width=100, box=box.MINIMAL)


# class ScrollbackReporting:
#     def __init__(self, console):
#         self.console = console
#         self._app = None

#     @property
#     def app(self):
#         return self._app

#     @app.setter
#     def app(self, app):
#         self.perf_timer = perf_time_sequence(mode=app.hardware)
#         self._app = app
#         self.console.print(Panel(Pretty(app), width=100))

#     def update(self, state):
#         fold = self.app.driver.report.cadence
#         zps = state.total_zones / next(self.perf_timer) * fold
#         report = iteration_report(state.iteration, state.time, zps)
#         self.console.print(
#             f"[cyan]{report.iteration:06d}[/cyan] "
#             f"[green]t={report.time:0.5f}[/green] "
#             f"[magenta]Mzps={report.zones_per_second/1e6:0.3f}[/magenta]"
#         )


# def run(apps: list[Sailfish], console: Console, use_dash=False):
#     """
#     Run a sequence of sailfish apps, with a rich dashboard
#     """
#     try:
#         if use_dash:
#             dash = Dashboard()
#             view = Live(dash.render(), console=console, refresh_per_second=10)
#             view.start()
#         else:
#             dash = ScrollbackReporting(console)

#         for app in apps:
#             configure_kernel_module(default_exec_mode=app.hardware)

#             dash.app = app
#             solver = make_solver(app)
#             fold = app.driver.report.cadence
#             state = next(solver)
#             plot = Plotting(app)

#             while state.time < app.driver.tfinal:
#                 state = next(solver)
#                 if state.iteration % fold == 0:
#                     dash.update(state)
#                     plot.update(state)

#             if app.plot == "end":
#                 plot.plot(state, action="show")

#     finally:
#         if use_dash:
#             view.stop()


@dataclass
class iteration_report:
    iteration: int
    time: float
    zps: float

    def __repr__(self):
        return (
            f"[{self.iteration:06d}] "
            f"t={self.time:0.5f} "
            f"Mzps={self.zps/1e6:0.3f} "
        )

    def __rich_console__(self, *args):
        yield (
            f"[cyan]{self.iteration:06d}[/cyan] "
            f"[green]t={self.time:0.5f}[/green] "
            f"[magenta]Mzps={self.zps/1e6:0.3f}[/magenta]"
        )


@dataclass
class run_summary:
    total_sec: float
    mean_zps: float

    def __repr__(self):
        return (
            f"total run time: {self.total_sec:0.5f} sec\n"
            f"mean Mzps: {self.mean_zps/1e6:0.3f}"
        )


def run(apps: list[Sailfish]):
    for app in apps:
        yield app

        configure_kernel_module(default_exec_mode=app.hardware)

        fold = app.driver.report.cadence
        tfinal = app.driver.tfinal
        states = make_solver(app)
        state = next(states)
        app_timer = perf_time_sequence(mode=app.hardware)
        fld_timer = perf_time_sequence(mode=app.hardware)

        sum_zps = 0.0
        fld_num = 0

        while state.time < tfinal:
            state = next(states)

            if state.iteration % fold == 0:
                sec = next(fld_timer)
                zps = state.total_zones / sec * fold
                sum_zps += zps
                fld_num += 1
                yield iteration_report(state.iteration, state.time, zps)
                yield state

        yield run_summary(total_sec=next(app_timer), mean_zps=sum_zps / fld_num)
        yield state


def scrollback_run_monitor(print):
    while True:
        event = yield

        if type(event) is Sailfish:
            app = event
            print(app)

        elif type(event) is run_summary:
            summary = event
            print()
            print(summary)
            print()

        elif type(event) is iteration_report:
            report = event
            print(report)


def reports_table(reports):
    from rich.table import Table

    table = Table(expand=False)
    table.add_column("iteration", style="cyan", justify="right")
    table.add_column("time", style="green")
    table.add_column("zones per second (millions)", style="magenta", justify="left")

    for report in reports:
        table.add_row(
            f"{report.iteration}",
            f"{report.time:0.5f}",
            f"{report.zps/1e6:0.3f}",
        )

    table.add_section()

    if any(reports):
        avg_zps = sum(r.zps for r in reports) / max(1, len(reports))
        table.add_row(None, None, f"{avg_zps/1e6:0.3f}", style="italic")

    return table


def dashboard_run_monitor(console):
    from rich.live import Live
    from rich.pretty import Pretty
    from rich.progress import Progress
    from rich.columns import Columns

    reports = deque()
    progress = Progress()
    app_struct = Pretty(str())
    dash = Columns([app_struct, reports_table(reports), progress])
    run_task = None
    job_num = 0

    with Live(dash, console=console, refresh_per_second=10) as live:
        while True:
            event = yield

            if type(event) is Sailfish:
                app = event
                job_num += 1
                duration = app.driver.tfinal - app.driver.tstart

                if run_task is not None:
                    progress.remove_task(run_task)

                run_task = progress.add_task(f"running {job_num}", total=duration)
                dash.renderables[0] = Pretty(app)

            elif type(event) is iteration_report:
                report = event
                reports.append(report)

                if len(reports) > 20:
                    reports.popleft()
                dash.renderables[1] = reports_table(reports)

            elif type(event) is run_summary:
                reports = deque()

            else:
                state = event
                evolved_time = state.time - app.driver.tstart
                progress.update(run_task, completed=evolved_time)


def num_zones(arg):
    """
    Promote an integer or two-tuple to a three-tuple of integers

    This factory function is used by the argparse type parameter to convert
    user input to a domain.num_zones parameter.
    """
    res = tuple(int(i) for i in arg.split(","))

    if len(res) == 1:
        return res + (1, 1)
    if len(res) == 2:
        return res + (1,)
    if len(res) == 3:
        return res
    raise ValueError(f"invalid argument for num_zones {arg}")


def reconstruction(arg):
    """
    Promote a string to a reconstruction model

    This factory function is used by the argparse type parameter to convert
    user input to a scheme.reconstruction parameter.
    """
    try:
        mode, theta = arg.split(":")
        return mode, float(theta)
    except ValueError:
        if arg == "plm":
            return arg, 1.5
        else:
            return arg


def deep_update(d, u):
    """
    Update a dictionary and any nested dictionaries recursively
    """
    for k, v in u.items():
        if isinstance(v, Mapping):
            d[k] = deep_update(d.get(k, dict()), v)
        else:
            d[k] = v
    return d


def unflatten(d):
    """
    Create a nested dict from a flat one with keys like a.b.c
    """
    res = dict()
    for key, value in d.items():
        parts = key.split(".")
        d = res
        for part in parts[:-1]:
            if part not in d:
                d[part] = dict()
            d = d[part]
        d[parts[-1]] = value
    return res


def scan_strategies():
    d = {
        "strategy.data_layout": ("fields-last", "fields-first"),
        "strategy.cache_flux": (True, False),
        "strategy.cache_prim": (True, False),
        "strategy.cache_grad": (True, False),
    }
    for p in product(*d.values()):
        yield unflatten(dict(zip(d.keys(), p)))


def sailfish_presets():
    return {"scan-strategies": scan_strategies()}


def sailfish(config, overrides):
    """
    Yield a sequence of sailfish app structs from a config

    The config may be the name of a preset, which may then be a dictionary
    or sequence of dictionaries, or it may be a path to a json file
    containing a dictionary or a list of dictionaries.
    """
    presets = sailfish_presets()

    if not config:
        cs = dict()
    elif config in presets:
        cs = presets[config]
    elif config.endswith(".json"):
        with open(config) as infile:
            cs = load_json(infile)
    else:
        raise ValueError("config must be a preset or a json file")

    if type(cs) is dict:
        cs = [cs]

    for c in cs:
        s = asdict(Sailfish())
        deep_update(s, c)
        deep_update(s, overrides)
        yield Sailfish(**s)


def main():
    """
    Main sailfish entry point and command line interface
    """
    from rich.console import Console
    from rich.logging import RichHandler
    from rich.traceback import install as install_rich_traceback

    parser = ArgumentParser(
        prog="sailfish_ui",
        usage=SUPPRESS,
        description="sailfish is a GPU-accelerated astrophysical gasdynamics code",
    )
    parser.add_argument(
        "_configs",
        metavar="configs",
        nargs="*",
        default=[dict()],
    )
    parser.add_argument(
        "--log-level",
        dest="_log_level",
        default="warning",
        choices=("debug", "info", "warning", "error", "critical"),
        help="log messages at and above this severity level",
    )
    # parser.add_argument(
    #     "--debug",
    #     action="store_true",
    #     dest="_debug",
    # )
    # parser.add_argument(
    #     "--plot",
    #     nargs="?",
    #     const="end",
    #     help=Sailfish.describe("plot"),
    #     choices=(None, "live", "end"),
    #     dest="plot",
    # )
    # parser.add_argument(
    #     "--show-config",
    #     choices=Sailfish.type_args("show_config"),
    #     help=Sailfish.describe("show_config"),
    #     type=str,
    #     dest="show_config",
    # )
    parser.add_argument(
        "--mode",
        "--hardware",
        dest="hardware",
        choices=Sailfish.type_args("hardware"),
        help="execution mode",
    )
    parser.add_argument(
        "-n",
        "--num-zones",
        "--resolution",
        type=num_zones,
        dest="domain.num_zones",
        metavar="N",
    )
    parser.add_argument(
        "-m",
        "--time-integration",
        choices=Scheme.type_args("time_integration"),
        help=Scheme.describe("time_integration"),
        dest="scheme.time_integration",
    )
    parser.add_argument(
        "-r",
        "--reconstruction",
        type=reconstruction,
        help=Scheme.describe("reconstruction"),
        dest="scheme.reconstruction",
        metavar="R",
    )
    parser.add_argument(
        "-e",
        "--tfinal",
        type=float,
        help=Driver.describe("tfinal"),
        dest="driver.tfinal",
        metavar="T",
    )
    parser.add_argument(
        "-f",
        "--fold",
        "--report-cadence",
        type=int,
        help=Report.describe("cadence"),
        dest="driver.report.cadence",
        metavar="F",
    )
    parser.add_argument(
        "--data-layout",
        type=str,
        choices=Strategy.type_args("data_layout"),
        help=Strategy.describe("data_layout"),
        dest="strategy.data_layout",
    )
    parser.add_argument(
        "--cache-prim",
        action="store_true",
        dest="strategy.cache_prim",
        default=None,
    )
    parser.add_argument(
        "--cache-flux",
        action="store_true",
        dest="strategy.cache_flux",
        default=None,
    )
    parser.add_argument(
        "--cache-grad",
        action="store_true",
        dest="strategy.cache_grad",
        default=None,
    )
    args = parser.parse_args()

    # =========================================================================
    # Configure logging
    # =========================================================================
    console = Console()
    handler = RichHandler(omit_repeated_times=False, console=console)
    logger = getLogger("sailfish")
    logger.addHandler(handler)
    logger.setLevel(args._log_level.upper())

    install_rich_traceback()

    # =========================================================================
    # Extract model configuration from parser args
    # =========================================================================
    overrides = unflatten(
        {k: v for k, v in vars(args).items() if v is not None and k[0] != "_"}
    )

    # =========================================================================
    # Generate a sequence of sailfish app structs and run them
    # =========================================================================
    apps = chain(*(sailfish(cfg, overrides) for cfg in args._configs))
    # monitor = scrollback_run_monitor(console.print)

    monitor = dashboard_run_monitor(console)
    next(monitor)

    for event in run(apps):
        monitor.send(event)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
        print("ctrl-c interrupt")
