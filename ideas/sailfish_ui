#!/usr/bin/env python3


from argparse import ArgumentParser, SUPPRESS
from collections import deque
from collections.abc import Mapping
from dataclasses import asdict, dataclass
from itertools import chain
from json import load, dumps
from logging import getLogger

from rich import box
from rich.console import Console
from rich.console import Group
from rich.live import Live
from rich.logging import RichHandler
from rich.panel import Panel
from rich.pretty import Pretty
from rich.progress import Progress
from rich.syntax import Syntax
from rich.table import Table
from rich.traceback import install

from app_config import Sailfish, Driver, Report, Strategy, Scheme
from new_kernels import perf_time_sequence, configure_kernel_module
from solver import make_solver


@dataclass
class iteration_report:
    iteration: int
    time: float
    zones_per_second: float


class Plotting:
    def __init__(self, app):
        self._axes = None
        self._line = None
        self._live = app.plot == "live"

        if app.plot:
            from matplotlib import pyplot as plt

            if app.plot == "live":
                plt.ion()
            self.plt = plt

    def update(self, state):
        if not self._live:
            return
        elif self._axes is None:
            self.plot(state)
        elif self.plt.get_fignums():
            self.plot(state)
            self._fig.canvas.flush_events()

    def plot(self, state, action=None):
        from numpy import linspace

        p = state.primitive
        x = linspace(0.0, 1.0, p.shape[0])
        line = self._line

        if line is None:
            self._line = self.axes().plot(x, p[:, 0], mfc="none")[0]
        else:
            line.set_ydata(p[:, 0])

        if action == "show":
            self.plt.show()

    def axes(self):
        if self._axes:
            return self._axes
        else:
            from matplotlib import pyplot as plt

            fig = plt.figure()
            ax1 = fig.add_subplot(111)
            self._axes = ax1
            self._fig = fig
            return ax1


class Dashboard:
    """
    A rich-renderable run monitor
    """

    def __init__(self):
        self._app = None
        self.group = Group("", "", "")

    @property
    def app(self):
        return self._app

    @app.setter
    def app(self, app):
        progress = Progress()
        duration = app.driver.tfinal - app.driver.tstart
        run_task = progress.add_task("running...", total=duration)

        self._app = app
        self.progress = progress
        self.run_task = run_task
        self.reports = deque()
        self.perf_timer = perf_time_sequence(mode=app.hardware)
        self.group.renderables[0] = self.app_config()
        self.group.renderables[1] = self.reports_table()
        self.group.renderables[2] = self.progress

    def reports_table(self):
        table = Table(expand=True)
        table.add_column("iteration", style="cyan", justify="right")
        table.add_column("time", style="green")
        table.add_column("zones per second (millions)", style="magenta", justify="left")
        reports = self.reports

        for report in reports:
            table.add_row(
                f"{report.iteration}",
                f"{report.time:0.5f}",
                f"{report.zones_per_second/1e6:0.3f}",
            )
        table.add_section()
        avg_zps = sum(r.zones_per_second for r in reports) / max(1, len(reports))
        table.add_row(None, None, f"{avg_zps/1e6:0.3f}", style="italic")
        return table

    def app_config(self):
        if self.app.show_config is None:
            return str()
        if self.app.show_config == "table":
            return self.app
        if self.app.show_config == "pretty":
            return Pretty(self.app)
        if self.app.show_config == "json":
            return Syntax(dumps(asdict(self.app), indent=4), lexer="json")
        if self.app.show_config == "dict":
            return Pretty(asdict(self.app))

    def update(self, state):
        fold = self.app.driver.report.cadence
        evolved_time = state.time - self.app.driver.tstart
        zps = state.total_zones / next(self.perf_timer) * fold
        report = iteration_report(state.iteration, state.time, zps)

        self.progress.update(self.run_task, completed=evolved_time)
        self.reports.append(report)

        if len(self.reports) > 20:
            self.reports.popleft()

        self.group.renderables[1] = self.reports_table()

    def render(self):
        return Panel.fit(self.group, width=100, box=box.MINIMAL)


def run(apps: list[Sailfish], console: Console):
    dash = Dashboard()

    with Live(dash.render(), console=console, refresh_per_second=30) as view:
        for app in apps:
            configure_kernel_module(default_exec_mode=app.hardware)

            dash.app = app
            solver = make_solver(app)
            fold = app.driver.report.cadence
            state = next(solver)
            plot = Plotting(app)

            while state.time < app.driver.tfinal:
                state = next(solver)
                if state.iteration % fold == 0:
                    dash.update(state)
                    plot.update(state)

            if app.plot == "end":
                plot.plot(state, action="show")


def num_zones(arg):
    """
    Promote an integer or two-tuple to a three-tuple of integers

    This factory function is used by the argparse type parameter to convert
    user input to a domain.num_zones parameter.
    """
    res = tuple(int(i) for i in arg.split(","))

    if len(res) == 1:
        return res + (1, 1)
    if len(res) == 2:
        return res + (1,)
    if len(res) == 3:
        return res
    raise ValueError(f"invalid argument for num_zones {arg}")


def reconstruction(arg):
    try:
        mode, theta = arg.split(":")
        return mode, float(theta)
    except:
        return arg


def deep_update(d, u):
    """
    Update a dictionary and any nested dictionaries recursively
    """
    for k, v in u.items():
        if isinstance(v, Mapping):
            d[k] = deep_update(d.get(k, dict()), v)
        else:
            d[k] = v
    return d


def unflatten(d):
    """
    Create a nested dict from a flat one with keys like a.b.c
    """
    res = dict()
    for key, value in d.items():
        parts = key.split(".")
        d = res
        for part in parts[:-1]:
            if part not in d:
                d[part] = dict()
            d = d[part]
        d[parts[-1]] = value
    return res


def main():
    parser = ArgumentParser(
        prog="sailfish_ui",
        usage=SUPPRESS,
        description="sailfish is a GPU-accelerated astrophysical gasdynamics code",
    )
    parser.add_argument("configs", nargs="*")
    parser.add_argument(
        "--log-level",
        default="warning",
        choices=("debug", "info", "warning", "error", "critical"),
        help="log messages at and above this severity level",
    )
    parser.add_argument(
        "--debug",
        action="store_true",
    )
    parser.add_argument(
        "--mode",
        "--hardware",
        dest="hardware",
        choices=Sailfish.type_args("hardware"),
        help="execution mode",
    )
    parser.add_argument(
        "-n",
        "--num-zones",
        "--resolution",
        type=num_zones,
        dest="domain.num_zones",
        metavar="N",
    )
    parser.add_argument(
        "-m",
        "--time-integration",
        choices=Scheme.type_args("time_integration"),
        help=Scheme.describe("time_integration"),
        dest="scheme.time_integration",
    )
    parser.add_argument(
        "-r",
        "--reconstruction",
        type=reconstruction,
        help=Scheme.describe("reconstruction"),
        dest="scheme.reconstruction",
        metavar="R",
    )
    parser.add_argument(
        "-e",
        "--tfinal",
        type=float,
        help=Driver.describe("tfinal"),
        dest="driver.tfinal",
        metavar="T",
    )
    parser.add_argument(
        "-f",
        "--fold",
        "--report-cadence",
        type=int,
        help=Report.describe("cadence"),
        dest="driver.report.cadence",
        metavar="F",
    )
    parser.add_argument(
        "--data-layout",
        type=str,
        choices=Strategy.type_args("data_layout"),
        help=Strategy.describe("data_layout"),
        dest="strategy.data_layout",
    )
    parser.add_argument(
        "--cache-prim",
        action="store_true",
        dest="strategy.cache_prim",
    )
    parser.add_argument(
        "--cache-flux",
        action="store_true",
        dest="strategy.cache_flux",
    )
    parser.add_argument(
        "--plot",
        nargs="?",
        const="end",
        help=Sailfish.describe("plot"),
        choices=(None, "live", "end"),
        dest="plot",
    )
    parser.add_argument(
        "--show-config",
        choices=Sailfish.type_args("show_config"),
        help=Sailfish.describe("show_config"),
        type=str,
        dest="show_config",
    )
    args = parser.parse_args()

    console = Console()
    handler = RichHandler(omit_repeated_times=False, console=console)
    logger = getLogger("sailfish")
    logger.addHandler(handler)
    logger.setLevel(args.log_level.upper())

    install(show_locals=args.debug)  # rich traceback
    cmdline_dict = unflatten({k: v for k, v in vars(args).items() if v is not None})

    def sailfish(config):
        if not config:
            cs = dict()
        else:
            with open(config) as infile:
                cs = load(infile)
        if type(cs) is dict:
            cs = [cs]
        for c in cs:
            s = asdict(Sailfish())
            deep_update(s, c)
            deep_update(s, cmdline_dict)
            yield Sailfish(**s)

    run(chain(*map(sailfish, [None] + args.configs)), console=console)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
        print("ctrl-c interrupt")
