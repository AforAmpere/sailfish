#!/usr/bin/env python3


from app_config import Sailfish
from solver import make_solver
from collections import deque
from dataclasses import dataclass
from rich.console import Console
from rich.live import Live
from rich.table import Table
from rich.console import Group
from rich.panel import Panel
from rich.progress import Progress
from new_kernels import perf_time_sequence, configure_kernel_module


@dataclass
class iteration_report:
    iteration: int
    time: float
    zones_per_second: float


class Plotting:
    def __init__(self, app):
        self._axes = None
        self._line = None
        self._live = app.plot == "live"

        if app.plot:
            from matplotlib import pyplot as plt

            if app.plot == "live":
                plt.ion()
            self.plt = plt

    def update(self, state):
        if not self._live:
            return
        elif self._axes is None:
            self.plot(state)
        elif self.plt.get_fignums():
            self.plot(state)
            self._fig.canvas.flush_events()

    def plot(self, state, action=None):
        from numpy import linspace

        p = state.primitive
        x = linspace(0.0, 1.0, p.shape[0])
        line = self._line

        if line is None:
            self._line = self.axes().plot(x, p[:, 0], mfc="none")[0]
        else:
            line.set_ydata(p[:, 0])

        if action == "show":
            self.plt.show()

    def axes(self):
        if self._axes:
            return self._axes
        else:
            from matplotlib import pyplot as plt

            fig = plt.figure()
            ax1 = fig.add_subplot(111)
            self._axes = ax1
            self._fig = fig
            return ax1


class Dashboard:
    """
    A rich-renderable run monitor
    """

    def __init__(self, app: Sailfish):
        progress = Progress()
        duration = app.driver.tfinal - app.driver.tstart
        run_task = progress.add_task("running...", total=duration)

        self.app = app
        self.progress = progress
        self.run_task = run_task
        self.reports = deque()
        self.perf_timer = perf_time_sequence(mode=app.hardware)
        self.group = Group(app, self.reports_table(), Panel(self.progress))

    def reports_table(self):
        table = Table(expand=True)
        table.add_column("iteration", style="cyan", justify="right")
        table.add_column("time", style="green")
        table.add_column("zones per second (millions)", style="magenta", justify="left")

        reports = self.reports

        for report in reports:
            table.add_row(
                f"{report.iteration}",
                f"{report.time:0.5f}",
                f"{report.zones_per_second/1e6:0.3f}",
            )
        table.add_section()
        avg_zps = sum(r.zones_per_second for r in reports) / max(1, len(reports))
        table.add_row(None, None, f"{avg_zps/1e6:0.3f}", style="italic")
        return table

    def update(self, state):
        fold = self.app.driver.report.cadence
        evolved_time = state.time - self.app.driver.tstart

        self.progress.update(self.run_task, completed=evolved_time)
        zps = state.total_zones / next(self.perf_timer) * fold
        report = iteration_report(state.iteration, state.time, zps)
        self.reports.append(report)

        if len(self.reports) > 20:
            self.reports.popleft()

        self.group.renderables[1] = self.reports_table()

    def render(self):
        return self.group


def run(app: Sailfish):
    console = Console(width=100)
    configure_kernel_module(default_exec_mode=app.hardware)

    dash = Dashboard(app)
    plot = Plotting(app)
    fold = app.driver.report.cadence
    solver = make_solver(app)
    state = next(solver)

    with Live(dash.render(), console=console, refresh_per_second=30) as view:
        while state.time < app.driver.tfinal:
            state = next(solver)
            if state.iteration % fold == 0:
                dash.update(state)
                plot.update(state)

        if app.plot == "end":
            plot.plot(state, action="show")


def main():
    from collections.abc import Mapping
    from dataclasses import asdict
    from argparse import ArgumentParser
    from json import load
    from loguru import logger
    from reporting import configure_logger

    def num_zones(arg):
        res = tuple(int(i) for i in arg.split(","))

        if len(res) == 1:
            return res + (1, 1)
        if len(res) == 2:
            return res + (1,)
        if len(res) == 3:
            return res
        raise ValueError(f"invalid argument for num_zones {arg}")

    def deep_update(d, u):
        for k, v in u.items():
            if isinstance(v, Mapping):
                d[k] = deep_update(d.get(k, dict()), v)
            else:
                d[k] = v
        return d

    parser = ArgumentParser()
    parser.add_argument("configs", nargs="*")
    parser.add_argument(
        "-n",
        "--num-zones",
        "--resolution",
        type=num_zones,
        default=None,
    )
    parser.add_argument(
        "-f",
        "--fold",
        type=int,
        default=None,
    )
    parser.add_argument(
        "--plot",
        nargs="?",
        default=None,
        choices=[None, "live", "end"],
        const="end",
    )
    args = parser.parse_args()

    configure_logger(logger, "warning")
    app_dict = asdict(Sailfish())

    for config in args.configs:
        with open(config) as infile:
            deep_update(app_dict, load(infile))

    if args.num_zones is not None:
        app_dict["domain"]["num_zones"] = args.num_zones
    if args.fold is not None:
        app_dict["driver"]["report"]["cadence"] = args.fold
    if args.plot is not None:
        app_dict["plot"] = args.plot

    app = Sailfish(**app_dict)
    run(app)


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print()
        print("ctrl-c interrupt")
